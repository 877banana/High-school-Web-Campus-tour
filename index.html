<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>建物内を歩く</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #instructions {
      position: absolute;
      top: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      cursor: pointer;
    }
  </style>

  <!-- importmap -->
  <script type="importmap">
  {
    "imports": {
      "three": "./three.module.js"
    }
  }
  </script>
</head>

<body>
  <div id="instructions">クリックして開始</div>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from './GLTFLoader.js';
    import { PointerLockControls } from './PointerLockControls.js';

    /* ========= 基本セットアップ ========= */
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75, window.innerWidth / window.innerHeight, 0.1, 1000
    );

    // 視点の初期高さ（必要ならここを調整）
    camera.position.set(0, 3, 10);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    /* ========= ライト ========= */
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 10, 7);
    scene.add(directionalLight);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.25);
    scene.add(ambientLight);

    /* ========= モデル読み込み ========= */
    const loader = new GLTFLoader();
    loader.load('一階廊下＋階段付き.glb', (gltf) => {
      scene.add(gltf.scene);
    }, undefined, (error) => {
      console.error('読み込みエラー:', error);
    });

    /* ========= カメラ操作 ========= */
    const controls = new PointerLockControls(camera, document.body);
    scene.add(controls.getObject());

    const instructions = document.getElementById('instructions');
    instructions.addEventListener('click', () => controls.lock());

    controls.addEventListener('lock', () => {
      instructions.style.display = 'none';
    });
    controls.addEventListener('unlock', () => {
      instructions.style.display = 'flex';
    });

    /* ========= 移動 ========= */
    const move = { forward: false, backward: false, left: false, right: false };
    let velocityY = 0;
    let canJump = false;

    const gravity = 30;
    const jumpSpeed = 10;
    const speed = 2;

    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();

    document.addEventListener('keydown', (event) => {
      switch (event.code) {
        case 'KeyW': move.forward = true; break;
        case 'KeyS': move.backward = true; break;
        case 'KeyA': move.left = true; break;
        case 'KeyD': move.right = true; break;
        case 'Space':
          if (canJump) {
            velocityY = jumpSpeed;
            canJump = false;
          }
          break;
      }
    });

    document.addEventListener('keyup', (event) => {
      switch (event.code) {
        case 'KeyW': move.forward = false; break;
        case 'KeyS': move.backward = false; break;
        case 'KeyA': move.left = false; break;
        case 'KeyD': move.right = false; break;
      }
    });

    /* ========= メインループ ========= */
    let prevTime = performance.now();

    function animate() {
      requestAnimationFrame(animate);

      const time = performance.now();
      const delta = (time - prevTime) / 1000;

      velocity.set(0, 0, 0);
      direction.z = Number(move.forward) - Number(move.backward);
      direction.x = Number(move.right) - Number(move.left);
      direction.normalize();

      if (move.forward || move.backward)
        velocity.z -= direction.z * speed * delta;
      if (move.left || move.right)
        velocity.x -= direction.x * speed * delta;

      controls.moveRight(-velocity.x);
      controls.moveForward(-velocity.z);

      // 重力
      velocityY -= gravity * delta;
      controls.getObject().position.y += velocityY * delta;

      // ★ 地面の高さ（必要に応じて調整）
      const floorHeight = 1.7;
      if (controls.getObject().position.y < floorHeight) {
        velocityY = 0;
        controls.getObject().position.y = floorHeight;
        canJump = true;
      }

      renderer.render(scene, camera);
      prevTime = time;
    }

    animate();

    /* ========= リサイズ ========= */
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

  </script>
</body>
</html>
